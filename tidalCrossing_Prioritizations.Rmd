---
title: "Tidal Crossing Priotization"
subtitle: Suffolk County- Long Island
output:
  word_document:
    toc: no
    reference_docx: styletemplate.docx
  html_document:
    code_folding: hide
    fig_caption: yes
    fig_width: 3
    highlight: kate
    theme: journal
    toc: yes
    toc_float: yes
---  

```{r setup, message=FALSE, warning=FALSE, include=FALSE}

knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE,
	fig.width = 3,
	fig.height = 3
)
```

## Tidal Prioritization

### Intention
This document is meant to outline and document the workflow of the data and methods used in the prioritization metrics of the tidal crossings assessed under TNC's methods. These methods are applied to all the crossings uniformly. Metrics specific to an individual crossing, will be based on the output from this code combined with other information useful to partners.

```{r priorizationFunctions, message=FALSE, warning=FALSE, include=FALSE, paged.print=TRUE}
# package setup and sourcing data etc.
source("functions/prioritization_functions.R")
source("00_libraries.R") # libraries used elsewhere and stored here for convienence
# source("code/rmdSetup.R")
library(GGally)
library(naniar)
# library(plotly)
library(kableExtra)
library(DT)
theme_set(theme_ipsum(base_family = 'Arial', base_size = 8, plot_title_size = 9, subtitle_size = 7) + theme(plot.margin = unit(c(0.5, 0.5, 0.5, 0.5), "cm")))

options(digits = 2, scipen = 999)
# knitr::opts_chunk$set(out.width = "100%")

```

### Starting Data source  
Data are currently sourced from 2 locations. The primary geographic data are found in a hosted feature layer on AGOL. These point geographies contain general spatial information on each crossing (town, cross roads etc.) along with the desktop assessment portion of the prioritization. Data were migrated to this platform from the original field datasheets for increased data QA and processing effeciencies. With that transfer desktop data found in the field data sheets are to be considered incomplete.     
Field data are currently maintained in excel spreadsheets hosted in the team's shared Box folder. These data include all field assessement data for those sites that were visited. This data will likely be transitioned to a more robust managed database structure. 
These data were collected primarily under the TNC-NH/NHDES Coastal Program protocol [^Resilient Tidal Crossings]. Deviations from these methods are documented here and will be described in more detail in other project documents. 
Data extracted from Tidal Crossings Field workbooks using a suite of functions found in _/functions_ directory.  To save memory and time a seperate script runs the extraction process and saves an output file (.rds) to the _/data_ folder within this working directory. These data can then be called in as needed here. Alternatively, running rmdSetup.R will source all functions and run updates on data if _'dataUpdate = TRUE'_, currently the default, found near top of code chunk. 


```{r data, message=FALSE, warning=FALSE, paged.print=TRUE}
LIculvertsAssessments <- readRDS("data/LIculvertsAssessments.rds") # tidal assessment workbooks, with varying degrees of completness. This is the bulk of the data collected, but does not include complete desktop assessments. Those data are recorded and managed in the AGOL-hosted feature _desktopData_. 
LIculvertData_location <- read_rds("data/LIculvertData_location.rds") # tidal assessment data joined to locations of crossings identified in assessments. 

LIculvertsAssessments %>% filter(crossingID != 71) %>% # FIXME: this crossing is a PIA needs review and fixing.
  select(crossingID, rawheights) %>% 
  unnest() %>% 
  unite(Feature, Position, col = "FP", sep = " ") %>% 
  select(crossingID, FP, adjustedHt) %>% 
  mutate(crossingID = as.numeric(crossingID)) %>% 
  spread(key = FP, value = adjustedHt) -> heights # heights are needed for some of the calculations. Perhaps a better method would be to use SQL-like queries referencing multiple tables as needed. 

LIculvertAssessmentData <- LIculvertData_location %>% left_join(heights) 
LIculvertAssessmentData %>% write_rds("data/LIculvertAssessmentData.rds") # Data are updated each run.
```

***
## Ecological Benefit  

### E1. Salt marsh complex size  
Scoring assigned by manually classifying crossings based on proximity to marsh complexes. Crossings in or adjacent to large complexes (>~15 acres in size) scored 5, crossings in or adjacent to smaller complexes were scored a 3, and crossings disconnected from any marsh complex were scored a 1. Manual classification was used due to inconsistent spatial relationships between the crossing locations and the marsh complexes. Often crossings are found on the edges or outside of the boundary of the marsh complex but are in important waterways connecting these complexes.  

 
```{r saltmarshComplex, message=FALSE, warning=FALSE, paged.print=TRUE}
# # Catchment data are joined/updated into the Desktop_Data hosted on AGOL for this
# catchment_data <- read_rds("data/LIculvert_Catchments.rds")  # This data is originally from Karen's model output. Revise as neede for new crossing locations.

(LIculvertData_location %>% select(MarshComplex_Scoring) %>% st_drop_geometry() %>% mutate(MarshComplex_Scoring = MarshComplex_Scoring) %>% 
  ggplot(aes(x = MarshComplex_Scoring, fill = as.factor(MarshComplex_Scoring))) + 
   geom_bar() + 
   geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
   scale_fill_tnc("gradient1") + 
   labs(title = "Scoring distribution of \nmarsh complex size", subtitle = "Scores manually classified", fill = "Scoring") + theme(strip.text.y = element_text(angle = 0)))

crossingLocations <- LIculvertData_location %>% select(crossingID) # use for rejoining later for final feature class.
# Like it? Add this metric to the prioritization table
# LIculvertPrioritization will be added to through out this code. 
LIculvertPrioritization <- LIculvertData_location %>% 
  mutate(Score_MarshComplex = as.numeric(MarshComplex_Scoring)) %>% 
  select(crossingID, Score_MarshComplex) %>%
  st_drop_geometry() # sf object was throwing errors and unwanted behaviour.


```

### E2. Salt marsh size upstream (whole catchment not just eval unit) 

*TODO:*  
- Confirm scoring for the size of marsh in the catchment. 


```{r Saltmarshupstream, message=FALSE, warning=FALSE, paged.print=FALSE}

LIculvertData_location %>% select(da_catchmentArea_saltMarsh) %>% 
  ggplot(aes(da_catchmentArea_saltMarsh)) + geom_histogram(bins = 50) + 
  labs(title = "Distribution of marsh \nacreage upstream of crossing", subtitle = "in catchment")

smsu <- LIculvertData_location %>% select(crossingID, da_catchmentArea_saltMarsh) %>% 
  mutate(Score_marshAc = as.numeric(cut(x = da_catchmentArea_saltMarsh, 
                             # breaks = c(-Inf, 1, 7, 25, 75, Inf),
                             breaks = c(-Inf, 1, 5, 10, 50, Inf),
                             labels = c(1:5), ordered_result = F))) %>% 
  st_drop_geometry()

smsu %>% 
  ggplot(aes(x = da_catchmentArea_saltMarsh, fill = as.factor(Score_marshAc))) + 
  scale_fill_tnc("gradient1") +
  geom_histogram(bins = 50) + scale_x_log10() + 
  labs(title = "Distribution of marsh \nacreage upstream of crossing", 
       subtitle = "log transformed",
       fill = "Proposed \nscoring")
```

To produce scoring that is distributed across the range of values, I created breaks by using log-transformed salt marsh area, which normalized the distribution, then roughly took equal intervals across the log-transformed x axis adjusting the break values to be whole numbers. Similar approaches were taken for other metrics with skewed distributions.

Which yielded the following:  

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
smsu %>% ggplot(aes(x = Score_marshAc, fill = as.factor(Score_marshAc))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", 
       title = "Marsh Acerage \nupstream of crossing", x = NULL, caption = "proposed breaks: <1; 1-5; 5-10; 10-50; >50") +
  theme(legend.position = "none")
  
# 
# smsu %>% 
#  group_by(Score_marshAc) %>% tally(name = "# of crossings") %>% gt::gt()
# 

# Like it? Add this metric to the prioritization table
# LIculvertPrioritization will be added to through out this code. 
LIculvertPrioritization <- LIculvertPrioritization %>% left_join({smsu %>% select(crossingID, Score_marshAc)}, by = "crossingID") 
# TODO: Pickup here with building out the prioritization scores.

```



***  
### E3. Degree of Tidal Restriction and AOP  

Consists of 3 _sub-metrics_ that when averaged yield the score for degree of tidal restriction.
These sub-metrics described below are:    
 - E3a: Tidal Range Ratio  
 - E3b: Crossing Ratio  
 - E3c: Erosion Classification  

#### E3a. Tidal Range Ratio  
Ratio of the upstream tidal range to downstream tidal range. Tidal range is estimated from the difference in elevation from the high water indicator stain and low tide elevation at the time of the assessment. A ratio of 0.5 would indicate that the downstream tidal range is twice as large as the upstream tidal range. A 1:1 ratio would mean that the tidal ranges are equal on both sides of the crossing.  

Are the crossings with large (>1) ratios considered impounded?

Followed NH documnetation [^Resilient Tidal Crossings]:
![Table 7:](tidalRangeRatioTable.PNG)


_QA NEEDS_
Crossing 62 has data that needs to be checked (Low tide elevation is 5' above road....)
Currently filtering values below 0.
_TO DO_ Should we consider using both the HWI stain and the wrack? Some crossings have only one of the two.

```{r tidalrange, message=FALSE, warning=FALSE, layout="l-body-outset", paged.print=TRUE}

trr <- LIculvertAssessmentData %>% 
  mutate(tidalRangeRatio = tidal_range_ratio(us_hwi_stain = `HWI Stain US`,
                                             ds_hwi_stain = `HWI Stain DS`,
                                             us_low_tide_elevation = `Low Tide Water Elevation US`, 
                                             ds_low_tide_elevation = `Low Tide Water Elevation DS`),
         submetric_TidalRange = crit_tidal_range(tidalRangeRatio)) %>% 
  select(crossingID, `HWI Stain US`, `Low Tide Water Elevation US`, `HWI Stain DS`, `Low Tide Water Elevation DS`, tidalRangeRatio, submetric_TidalRange) %>% 
  select(crossingID, tidalRangeRatio, submetric_TidalRange) %>% filter(tidalRangeRatio > 0)

trr %>% st_drop_geometry %>% tidyr::drop_na() %>% 
  ggplot(aes(x = tidalRangeRatio, fill = as.factor(submetric_TidalRange))) + 
  geom_histogram(bins = 60) +
  scale_fill_tnc("gradient1") +
  labs(title = "Tidal range ratio distribution", fill = "Proposed \nscoring") + theme(legend.position = "right")

trr %>% st_drop_geometry %>% tidyr::drop_na() %>% 
  ggplot(aes(x = submetric_TidalRange, fill = as.factor(submetric_TidalRange))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Tidal range ratio", x = NULL ) +
  theme(legend.position = "none")

#  
# Save results of the tidal range ratio portion to a new object. 
LIculvertPrioritization <- LIculvertPrioritization %>% left_join({trr %>% st_drop_geometry()}, by = "crossingID")


```  


There are many sites that do not have enough data to calculate the tidal range ratios. 
**`r LIculvertPrioritization %>% filter(!is.na(tidalRangeRatio)) %>% nrow`** crossings have tidal range ratios calculated.


#### E3b. Crossing Ratio
Crossing ratio is calculated from the greater of 2 ratios. The ratio of crossing structure to the stream section, for both the up and downstream sides. **A wide river with a small structure opening will score high, indicating a restriction**.

```{r crossingratios, message=FALSE, warning=FALSE, paged.print=TRUE}
#IDEA: prefix all scoring variables with 'eval_'
# Workflow: Create a master tibble that will be added to with each code block. 
cr <- LIculvertAssessmentData %>% 
  # Calculate the up and down stream crossing ratios
  mutate(crossingRatio_upStrm = crossing_ratio(channelWidth = da_ChannelWidth_upStream, # TODO: QA data in desktop
                                               dimA = CrosDim_upA, 
                                               dimC = crossDim_upC),
    crossingRatio_dwStrm = crossing_ratio(channelWidth = da_ChannelWidth_dwnStream, 
                                          dimA = CrosDim_dwnA, 
                                          dimC = CrosDim_dwnC),
    crossingRatio = pmax(crossingRatio_dwStrm, crossingRatio_upStrm),
    # calculate the crossing ratio evaluation score.
    submetric_crossingRatio = crit_crossing_ratio(crossing.ratio = crossingRatio)) %>% #NOTE: Must use pmax with dplyr! And must score for final prioritizations.
  select(crossingID, crossingRatio, submetric_crossingRatio)

# # Show table of inspecting
# cr %>% st_drop_geometry() %>%  datatable(rownames = FALSE) %>% 
#   formatRound(-1, digits = 2) 

cr %>% st_drop_geometry %>% 
  ggplot(aes(x = crossingRatio, fill = as.factor(submetric_crossingRatio))) + 
  geom_histogram() + 
  scale_fill_tnc("gradient1") +
  scale_x_log10() +
  labs(title = "Crossing Raio distribution", subtitle = "log 10 transformed", fill = "Proposed \nscoring")

cr %>% st_drop_geometry %>%# tidyr::drop_na() %>% 
  ggplot(aes(x = submetric_crossingRatio, fill = as.factor(submetric_crossingRatio))) + 
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Crossing Ratio", x = NULL ) +
  theme(legend.position = "none")


# Like what we see? Join to the master LIculvertPrioritization tibble.
LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({cr %>% st_drop_geometry()}, by = "crossingID")

```

***  
#### E3c. Erosion Classification  
 
The ratio of scour pool width to channel width for both up and down stream sections. A large ratio indicates a larger scour pool. The final Erosion Classification score is based on the _LARGER_ of the 2 ratios (up and downstream)

```{r erosionClass, message=FALSE, warning=FALSE, paged.print=TRUE}

ec <- LIculvertAssessmentData %>% 
  # Calculate the up and down stream classification 'raw' scores
  mutate(erosionClass_upStrm = erosion_class(scour_pool = da_MaxPoolWidth_upStream, 
                                             channel_width = da_ChannelWidth_upStream),
         erosionClass_dwnStrm = erosion_class(scour_pool = da_MaxPoolWidth_dwnStream, 
                                              channel_width = da_ChannelWidth_dwnStream),
         # calculate the erosion classification evaluation score.
    submetric_erosionClass = crit_erosion_class(us_eclass = erosionClass_upStrm, 
                                             ds_eclass = erosionClass_dwnStrm)) %>% 
  select(crossingID, erosionClass_upStrm, erosionClass_dwnStrm, submetric_erosionClass)

ec %>% st_drop_geometry %>% tidyr::drop_na() %>% 
  ggplot(aes(x = erosionClass_dwnStrm, fill = as.factor(submetric_erosionClass))) + 
  geom_histogram() + 
  scale_fill_tnc("gradient1") + 
  scale_x_log10() +
  labs(title = "Downstream Erosion \nClassification", subtitle = "log transformed", fill = "submetric \nscoring")

ec %>% st_drop_geometry %>% tidyr::drop_na() %>% 
  ggplot(aes(x = submetric_erosionClass, fill = as.factor(submetric_erosionClass))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Crossing Ratio", x = NULL, fill = "submetric \nscoring") +
  theme(legend.position = "none")

ec %>% st_drop_geometry %>% tidyr::drop_na() %>% 
  ggplot(aes(x = erosionClass_upStrm, fill = as.factor(submetric_erosionClass))) + 
  geom_histogram() + 
  scale_fill_tnc("gradient1") + 
  scale_x_log10() +
  labs(title = "Upstream Erosion \nClassification", subtitle = "log transformed", fill = "submetric \nscoring")

# NOTE: These distributions, or the color scheme of the scoring applied to thesee distributions are odd not discretely binned as you'd think they would be because the scoring is calculated by taking the max of the upstream and downstream ratios and scoring accordingly.

# Like what we see? Join to the master LIculvertPrioritization tibble.
# BUG: There's duplicate crossings entering here somehow.
LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({ec  %>% st_drop_geometry()}, by = "crossingID")

```

***   

#### Degree of Tidal Restriction Scoring  
Average of 3 submetrics (E3a, E3b, E3c)

Combining the scores of the tidal range ratio, Crossing ratio, erosion classification to yield Degree of Tidal Restriction score. Resulting averages are then rounded to the nearest whole integer value for the final score.
_TO DO_ Check in with team that this is preferred method. 

This set of plots are a bit of an eye-twister, but is the distribution of each of the 'submetrics' that are then color coded by their final score. i.e. There's 10 crossings that scored a 1 for the tidal range ratio, but a 3 for the final DOTR overall score. There aren't any strong correlations across these submetrics (see correlation matrix below). 

```{r DOTR_TAOP, fig.width=7, fig.height=7, message=FALSE, warning=FALSE, paged.print=TRUE}
dtr <- LIculvertPrioritization %>% rowwise() %>% 
  # Calculate the up and down stream classification 'raw' scores
  mutate(Score_dotr = round(degtidalrestr(tidal_rng_score = submetric_TidalRange, 
                                         crossing_ratio_score = submetric_crossingRatio,
                                         erosion_class_score = submetric_erosionClass)),
         Score_dotr_unround = degtidalrestr(tidal_rng_score = submetric_TidalRange, 
                                         crossing_ratio_score = submetric_crossingRatio,
                                         erosion_class_score = submetric_erosionClass),
         Score_dotr_binned = cut(x = Score_dotr_unround, breaks = c(-Inf, 1.4999, 2.4999, 3.4999, 4.4999, Inf), labels = c(1:5))) %>% 
  select(crossingID, submetric_TidalRange, submetric_crossingRatio, submetric_erosionClass, Score_dotr, Score_dotr_unround, Score_dotr_binned)

tidal_dtr <- dtr %>%  
  ggplot(aes(x = submetric_TidalRange, fill = as.factor(Score_dotr))) + 
  geom_bar() +
  scale_fill_tnc("gradient1") +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(fill = "Proposed \nScoring", title = "Tidal range ratio")
cross_dtr <- dtr %>%  
  ggplot(aes(x = submetric_crossingRatio, fill = as.factor(Score_dotr))) + 
  geom_bar() +
  scale_fill_tnc("gradient1") +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(fill = "Proposed \nScoring", title = "Crossing ratio")
erosion_dtr <- dtr %>%  
  ggplot(aes(x = submetric_erosionClass, fill = as.factor(Score_dotr))) + 
  geom_bar() +
  scale_fill_tnc("gradient1") +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(fill = "Proposed \nScoring", title = "Erosion class")
final <- dtr %>%  
  ggplot(aes(x = Score_dotr_binned, fill = as.factor(Score_dotr_binned))) + 
  geom_bar() +
  scale_fill_tnc("gradient1") +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(title = "E3. Degree of tidal restriction", fill = "Proposed \nscoring")
tidal_dtr + cross_dtr + erosion_dtr + final

# dtr %>% select(starts_with("subm")) %>% ggpairs()
# dtr %>%  
#   ggplot(aes(x = Score_dotr, fill = as.factor(Score_dotr))) + 
#   geom_bar() +
#   scale_fill_tnc("gradient1") +
#   geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
#   labs(title = "E3. Degree of tidal restriction", fill = "Proposed \nscoring")


LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({dtr %>% select(crossingID, Score_dotr)}, by = "crossingID")


```


### E4. Vegetation Score 
Field assessed classification of vegetation at the crossing. Based on NH methods. Scored by presence/absence of invasives and species composition upstream and downstream of crossing. This assumes that the crossing structure impacts the hydrology to varying degrees, which results in species composition differences on either side of the crossing. Additionally, the presence of invasive species are considered.

Currently we don't have an 'official' scoring method for the vegetation score. NH follows the  scoring below, which is based on a 0-5 range. 
![Vegetation scoring matrix](vegmatrix.PNG)

Their approach is to essentially drop any crossings that have invasives, by scoring them a 0 and adding them to a sort of 'restoration' list. This seems to make sense as they have another restoration project prioritization tool that they seem to be referring to in the documentation. For us though, probably not relevant. My propsed scoring is below and represented in the plot that follows. 
_We'll need to resolve this before final scoring._


vegMatChoice == "1A"  =  1, # native only, same both sides  
vegMatChoice == "2A" = 1, # invasives through out, same both sides  
vegMatChoice == "2B" = 2, # invasives through out, up and down stream communtites are slightly different 
vegMatChoice == "1B"  =  3, # native only, different species on either side but appear similar (high marsh - low marsh)  
vegMatChoice == "3A" = 3, # invasives on one side, tidal marsh on both sides  
vegMatChoice == "2C" = 4, # invasives through out, up and down stream communities represent different marsh types 
vegMatChoice == "3B" = 4, # invasives on one side, similar species/marsh type on either side   
vegMatChoice == "3C" = 5 # invasices on one side, up and down stream different species  
vegMatChoice == "1C" = 5, # native only, tidal species one side, fresh species the other.  

```{r vegetationScore, message=FALSE, warning=FALSE, paged.print=TRUE}

vegsc <- LIculvertAssessmentData %>% 
  select(crossingID, Vegchoice) %>% mutate(Score_vegetation = vegetationScore(Vegchoice))

# Made Unassessed a -2 score for display in plots. .
vegsc %>% select(Score_vegetation) %>% 
  mutate(Score_vegetation_na = replace_na(Score_vegetation, replace = -2)) %>% # hack to get NAs to plot.
  ggplot(aes(x = Score_vegetation_na, fill = as.factor(Score_vegetation_na))) + 
  geom_bar() + 
  scale_fill_manual(values = c("gray","#49a942", "#a0c04d", "#ffe04f", "#f3901d", "#c5351c")) +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  scale_x_continuous(breaks = c(-2, 0:5)) + 
  labs(subtitle = "Unassessed = -2", main = "Vegetation matrix scoring distribution", fill = "")

LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({vegsc %>% select(crossingID, Score_vegetation) %>% st_drop_geometry()}, by = "crossingID")

```

## Total Ecological Benefit Score

```{r ecobenefitScore, message=FALSE, warning=FALSE, paged.print=FALSE}



# score_ecobenefit = sum of each benefit score within, rescale to 1-5. 
#'
# Score_MarshComplex
# Score_marshAc
# Score_dotr
# Score_vegetation


LIculvertPrioritization <- LIculvertPrioritization %>% rowwise() %>% 
  mutate(Total_Eco = benefit_score(sum(Score_MarshComplex, Score_marshAc, Score_dotr, Score_vegetation, na.rm = F))) %>% ungroup()



LIculvertPrioritization %>%  
  ggplot(aes(x = Total_Eco, fill = as.factor(Total_Eco))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Ecological Benefit", x = NULL ) +
  theme(legend.position = "none")


```

***  

## Resilience Benefit   

### R1. Risk of sea level rise inundation to the road  
Risk of sea level rise inundation is 

```{r slrInud, message=FALSE, warning=FALSE}

slrIn <- LIculvertData_location %>% st_drop_geometry() %>%
  select(crossingID, starts_with("Suffolk")) %>%
  mutate(
    Score_riskSLR_inundation = case_when(
      Suffolk_2085_LOW_Inund_Freq == 0 |
        Suffolk_2085_LOW_Inund_Freq == 1 |
        Suffolk_2085_LOWMED_Inund_Freq == 0 |
        Suffolk_2085_LOWMED_Inund_Freq == 1 ~ 5,
      Suffolk_2085_MED_Inund_Freq == 0 |
        Suffolk_2085_MED_Inund_Freq == 1 ~ 4,
      Suffolk_2085_HIGHMED_Inund_Freq == 0 |
        Suffolk_2085_HIGHMED_Inund_Freq == 1 ~ 3,
      Suffolk_2085_HIGH_Inund_Freq == 0 |
        Suffolk_2085_HIGH_Inund_Freq == 1 ~ 2,
      TRUE ~ 1 # all others get a 1.
    ),
    # Summary sheet info.
    ss_Suffolk_2085_HIGHMED_Inund_Freq = recode(
      Suffolk_2085_HIGHMED_Inund_Freq,
      # How often is..inundated 2080s
      `0` = "Open Water",
      `1` = "Inundated at least once every 30 days",
      `2` = "Inundated at least once every 60 days",
      `3` = "Inundated at least once every 90 days",
      `4` = "Inundated by the 10-year storm",
      `5` = "Inundated by the 100-year storm",
      `6` = "Never",
      `7` = "Below the 100-year storm but connected",
      `8` = "Protected by dikes",
      `-99` = "Never",
      .default = "Never",
      .missing = "Never"
    )
  )


slrIn %>% 
  ggplot(aes(x = Score_riskSLR_inundation, fill = as.factor(Score_riskSLR_inundation))) + 
  geom_bar() + 
  scale_fill_tnc("gradient1") +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  scale_fill_tnc("gradient1") + 
  labs(title = "Risk of SLR inundation 2080's",
       fill = "Proposed \nscoring")



LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({slrIn %>% 
      select(crossingID, Score_riskSLR_inundation, ss_Suffolk_2085_HIGHMED_Inund_Freq)}, by = "crossingID")


```

### R2. Risk of storm surge inundation to the road   


```{r}


stormSurgeIn <- LIculvertData_location %>% st_drop_geometry() %>%
  select(crossingID, Suffolk_InitialCondition_Inund_Freq) %>%
  mutate(
    Score_stormsuge = case_when(
      Suffolk_InitialCondition_Inund_Freq == 0 |
        Suffolk_InitialCondition_Inund_Freq == 1 ~ 5,
      Suffolk_InitialCondition_Inund_Freq == 2 |
        Suffolk_InitialCondition_Inund_Freq == 3 ~ 4,
      Suffolk_InitialCondition_Inund_Freq == 4 ~ 3,
      Suffolk_InitialCondition_Inund_Freq == 5 ~ 2,
      TRUE ~ 1
    ),
    ss_Suffolk_InitialCondition_Inund_Freq	= recode(
      Suffolk_InitialCondition_Inund_Freq,
      # present day storm freq
      `0` = "Open Water",
      `1` = "Inundated at least once every 30 days",
      `2` = "Inundated at least once every 60 days",
      `3` = "Inundated at least once every 90 days",
      `4` = "Inundated by the 10-year storm",
      `5` = "Inundated by the 100-year storm",
      `6` = "Beyond the 100-year storm",
      `7` = "Below the 100-year storm but connected",
      `8` = "Protected by dikes",
      `-99` = "Beyond the 100-year storm",
      .default = "Beyond the 100-year storm",
      .missing = "Beyond the 100-year storm"
    )
  )



stormSurgeIn %>% 
  ggplot(aes(x = Score_stormsuge, fill = as.factor(Score_stormsuge))) + 
  geom_bar() + 
  scale_fill_tnc("gradient1") +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  scale_fill_tnc("gradient1") + 
  labs(title = "Risk of storm surge inundation to road",
       fill = "Proposed \nscoring")



LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({stormSurgeIn %>% 
      select(crossingID, Score_stormsuge, ss_Suffolk_InitialCondition_Inund_Freq)}, by = "crossingID")


```

### R3. Heavy rainfall flood risk of the catchment   
Following the freshwater prioritization scoring break down:   

| % Imper | Score|
|........:|:.....|
| >40%    |  5   | 
| 30-40%  |  4   |
| 20-30%  |  3   |
| 10-20%  |  2   |
| <10%    |  1   |

```{r impervious, message=FALSE, warning=FALSE}

LIculvertData_location %>% ggplot(aes(x = da_catchmentLndCover_imperv)) +  geom_histogram()
  
rainrisk <- LIculvertData_location %>% select(crossingID, da_catchmentLndCover_imperv) %>% mutate(Score_rainfallRisk= as.numeric(cut(x = da_catchmentLndCover_imperv, breaks = c(-Inf, 10, 20, 30, 40, Inf), labels = c(1:5)))) # created breaks by using log-transformed salt marsh area, which normalized the distribution, then roughly took equal intervals across the log-transformed x axis adjusting the break values to be whole numbers.

rainrisk %>% st_drop_geometry() %>% tidyr::drop_na() %>% 
  ggplot(aes(x = da_catchmentLndCover_imperv, fill = as.factor(Score_rainfallRisk))) + 
  geom_histogram(bins = 30) + 
  scale_fill_tnc("gradient1") + 
  labs(title = "Distribution of impervious % \n upstream of crossing",
       fill = "Proposed \nscoring", x = "% impervious")

# rainrisk %>% group_by(Score_rainfallRisk) %>% st_drop_geometry() %>% tally() %>% gt::gt()
 

LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({rainrisk %>% select(crossingID, Score_rainfallRisk) %>% st_drop_geometry()}, by = "crossingID")


```



### R4. Area of potential tidal marsh advancement upstream of restriction  

proposed breaks: <1; 1-7, 7-25, 25-75, >75
Same breaks as the marsh size

Distribution of marsh migration potentianl across catchments.

```{r marshmigrationPot, message=FALSE, warning=FALSE}

p("Untransformed distribution skewed heavily as expected")
LIculvertData_location %>% ggplot(aes(x = da_MarshMigrPot_acres)) +  geom_histogram() + 
  labs(title = "Distribution of  marsh migration \npotential across crossings")

p("Log transformed values, ~normally distributed.")
LIculvertData_location %>% ggplot(aes(x = da_MarshMigrPot_acres)) +  
  geom_histogram() + 
  scale_fill_tnc("gradient1") + 
  labs(title = "Distribution of  marsh migration \npotential across crossings", subtitle = "log transformed") + scale_x_log10()

p("Scoring of log-transformed data")
LIculvertData_location %>% select(crossingID, da_MarshMigrPot_acres) %>% mutate(Score_marshmigpotAc = as.numeric(cut(x = da_MarshMigrPot_acres, breaks = c(-Inf, 1, 7, 25, 75, Inf), labels = c(1:5), ordered_result = F))) %>%
  ggplot(aes(da_MarshMigrPot_acres, fill = as.factor(Score_marshmigpotAc))) + geom_histogram() + 
  scale_fill_tnc("gradient1") + 
  labs(title = "Distribution of  marsh migration \npotential across crossings", subtitle = "log transformed", fill = "Score") + scale_x_log10()
  
smmp <- LIculvertData_location %>% select(crossingID, da_MarshMigrPot_acres) %>% mutate(Score_marshmigpotAc = as.numeric(cut(x = da_MarshMigrPot_acres, breaks = c(-Inf, 1, 7, 25, 75, Inf), labels = c(1:5))))# created breaks by using log-transformed salt marsh area, which normalized the distribution, then roughly took equal intervals across the log-transformed x axis adjusting the break values to be whole numbers.

smmp %>% 
  ggplot(aes(x = Score_marshmigpotAc, fill = as.factor(Score_marshmigpotAc))) + 
  geom_histogram(bins = 20) + 
  scale_fill_tnc("gradient1") + 
  labs(title = "Distribution of potential \ntidal marsh advancment \nupstream of crossing",
       fill = "Proposed \nscoring")
# proposed breaks: <1; 1-7, 7-25, 25-75, >75
# smcs %>% mutate(Score_marshAc = cut(x = log10(MARSH_AC+1), breaks = 5)) %>% st_drop_geometry() %>% 
#   # group_by(Score_marshAc) %>% ggplot(aes(x = as.integer(Score_marshAc))) + geom_histogram() +
#   #   stat_bin(aes(y=..count.., label=..count..), geom ="text", vjust=-.5) 
# group_by(Score_marshAc) %>% tally()
# 
# smmp %>% st_drop_geometry() %>% 
#  group_by(Score_marshmigpotAc) %>% tally(name = "# of crossings") %>% gt::gt()

# Like it? Add this metric to the prioritization table
# LIculvertPrioritization will be added to through out this code. 


LIculvertPrioritization <- LIculvertPrioritization %>% left_join({smmp %>% select(crossingID, Score_marshmigpotAc) %>% st_drop_geometry()}, by = "crossingID") 


```


### Total Resilience Benefit Score   

```{r totResilienceSc, message=FALSE, warning=FALSE, paged.print=FALSE}


LIculvertPrioritization <- LIculvertPrioritization %>% rowwise() %>% 
  mutate(Total_Resilience = benefit_score(sum(Score_riskSLR_inundation, Score_stormsuge, Score_rainfallRisk, Score_marshmigpotAc, na.rm = F)), resilience.score = TRUE) %>% ungroup()

LIculvertPrioritization %>%  
  ggplot(aes(x = Total_Resilience, fill = as.factor(Total_Resilience))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Resilience Benefit", x = NULL ) +
  theme(legend.position = "none")


```

***  
## Transportation Benefit  

### T1. Road Functional Classification  
NYSDOT Road functional class data were spatially joined to each crossings. Crossings not aligned with NYSDOT road data (i.e. on foot paths or small unpaved roads) were classified manually, using aerial imagery, field notes, and NYSDOT road data layers as guidance. 

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
# Data for finding road functional classification 
# See road_classification.R code 
# TODO: append the road classification data to the feature service hosted on AGOL 
# roadData <- read_rds(path = "data/roadFunctional_class.rds")

tb <- LIculvertData_location %>% #select(FunctionalClass_supervised) %>% 
  select(crossingID, FunctionalClass_supervised, Evac_Rte) %>% 
  mutate(
    ss_Rd_EvacRte = if_else(Evac_Rte == 1, "Yes", "No"), # IDEA: Add prefixes to the data needed for the summary sheets.
    Score_Rd_EvacRte = if_else(Evac_Rte == 1, true = 5, false = 1), 
    ss_Functional_Class = recode(FunctionalClass_supervised, #TODO: Need to recode class 6-7-9 
                                   `-99` = "Undefined",
                                 `99` = "Railroad",
                                 `-98` = "Trail/Path/Other",
                                   `11` = "Principal Arterial - Interstate",
                                   `12` = "Principal Arterial - Other Freeway/Expressway",
                                   `14` = "Principal Arterial - Other", 
                                   `16` = "Minor Arterial",
                                   `17` = "Major Collector",
                                   `18` = "Minor Collector",
                                   `19` = "Local",
                                 `6` = "Rural- Minor Arterial",
                                 `7` = "Rural- Major Collector",
                                 `9` = "Rural- Local"
                                 ),
    Score_Rd_Funclass = recode(FunctionalClass_supervised,
                              `-99` = -99,
                                   `11` = 5, #"Principal Arterial - Interstate",
                                   `12` = 5, #"Principal Arterial - Other Freeway/Expressway",
                                   `14` = 5, #"Principal Arterial - Other", 
                                   `16` = 4, #"Minor Arterial",
                                   `17` = 3, #"Major Collector",
                                   `18` = 2, #"Minor Collector",
                                   `19` = 1,  #"Local")) Some local roads might be very important!
                              `6` = 1, #"Rural- Minor Arterial",
                                 `7` = 1, #"Rural- Major Collector",
                                 `9` = 1)) # "Rural- Local"))


LIculvertPrioritization <- LIculvertPrioritization %>%  
  left_join({tb %>% select(crossingID, Score_Rd_EvacRte, Score_Rd_Funclass) %>% st_drop_geometry()}, by = "crossingID")

LIculvertPrioritization %>%  
  ggplot(aes(x = Score_Rd_Funclass, fill = as.factor(Score_Rd_Funclass))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Functional Class Benefit", x = NULL ) +
  theme(legend.position = "none")


```

### T2. Evacuation Route   
NYSDOT Road Evacuation routes were spatially joined to crossings, and reviewed for completeness and accuracy. Scores were   
```{r message=FALSE, warning=FALSE, paged.print=FALSE}
LIculvertPrioritization %>%  
  ggplot(aes(x = Score_Rd_EvacRte, fill = as.factor(Score_Rd_EvacRte))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Evacuation Route Benefit", x = NULL ) +
  theme(legend.position = "none")


```


### Total Transportation Benefit Score  
```{r message=FALSE, warning=FALSE, paged.print=FALSE}

LIculvertPrioritization <- LIculvertPrioritization %>% rowwise() %>% 
    mutate(Total_Trans = benefit_score(sum(Score_Rd_EvacRte, Score_Rd_Funclass, na.rm = T))) %>% ungroup()

LIculvertPrioritization %>%  
  ggplot(aes(x = Total_Eco, fill = as.factor(Total_Eco))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Transportation Benefit", x = NULL ) +
  theme(legend.position = "none")


```


***
## Infrastructure Condition Benefit  

### C1. Crossing Condition  
_Current crossing condition_ evaluates several components of the crossing structure to effectively summarize the overall condition. Structure condition, such as headwall and wingwall condition. Scour has been removed as that condition is found in _Eroision Classification_. 

#### Testing condition scoring with and without scour scores.
Following the NH protocol the first version of scoring includes the severity of scour (eval_crossCondition). eval_crossCondition_v2 only includes the conditions of the 5 components of the crossings. See prioritization functions for details. 

```{r crossingConditionEval, message=FALSE, warning=FALSE, paged.print=TRUE}

crscond <- LIculvertAssessmentData %>% st_drop_geometry() %>% 
  select(crossingID, 
         RoadSurfaceCondition,
         StructureConditionOverall, 
         HeadwallCondition_dwnStream, 
         HeadwallCondition_upStream,
         WingwallCondition_dwnStream,
         WingwallCondition_upStream) %>% rowwise() %>% 
  
  mutate(Score_crossConditon = crossingConditionScore(overallCond = StructureConditionOverall,
                                                     hwall_upCond = HeadwallCondition_upStream, 
                                                     wwall_upCond = WingwallCondition_upStream, 
                                                     hwall_dwnCond = HeadwallCondition_dwnStream, 
                                                     wwall_dwnCond = WingwallCondition_dwnStream, 
                                                     roadCond = RoadSurfaceCondition)) %>% 
  ungroup()

# correlation and distrbution plots
# (crscond %>% select(-crossingID) %>%  
#   ggpairs(title = "Crossing Condition and components feeding into") + theme(strip.text.y = element_text(angle = 0))) %>% ggplotly()

crscond %>% 
  ggplot(aes(x = Score_crossConditon, fill = as.factor(Score_crossConditon))) + 
  geom_bar() + geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  scale_fill_tnc("gradient1") + 
  labs(title = "Crossing condition score distribution", fill = "Score")

# Like it? Add this metric to the prioritization table
LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({crscond %>% select(crossingID, Score_crossConditon)}, by = "crossingID")

```

### C2. Partner priority
Partner priority provided to TNC 2018-2019.

```{r partnerPrior, message=FALSE, results='asis', warnings=FALSE}

partpr <- LIculvertAssessmentData %>% #
  select(crossingID, PtrPriorit, TNCPriorit) %>% 
  mutate(Score_partPrior = case_when(PtrPriorit == 1 ~ 5L,
                               is.na(PtrPriorit) ~ 1L,
                               PtrPriorit == 0 ~ 1L,
                               TNCPriorit == 1 ~ 5L))


partpr %>% ggplot(aes(x = Score_partPrior, fill = as.factor(Score_partPrior))) + 
  geom_bar() + geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) + 
  scale_fill_tnc("gradient1") +
  labs(title = "Partner priority", fill = "Score")
# Like it? Add this metric to the prioritization table
LIculvertPrioritization <- LIculvertPrioritization %>% 
  left_join({partpr %>% select(crossingID, Score_partPrior) %>% st_drop_geometry()}, by = "crossingID")

```

### C3. High water risk: Lack of clearance

Not all crossings have sufficient data to calculate this metrc. In those cases, crossings are scored a NA and are not included in the averaging of the Infrastructure Condition benefit scores. 

Placeholder:
It just occured to me that this effectively gets at the same question that we ask in the 'Risk of Storm Surge' benefit score. i.e. how low is the road to the tides. Would that be a better scoring mechanism/approach?

_IDEA:_ Attempt at using a high water indicator/lack of clearance RATIO instead of the absolute difference measures used by NH. 

hwi-loc ratio:
$$ scaleAdjust^{high water} = minimum(hwi^{stain} | \ road \ center \ height )$$
$$ scaleAdjust^{lack \ of \ clearance} = minimum(hwi^{wrack} | \ ceiling \ of \ structure )$$
$$ highwater \ clearance \ risk \ ratio = scaleAdjust + (hwi^{stain} |  hwi^{wrack}) / scaleAdjust + Road \ Height$$

This yeilds a value that's been adjusted to the be

```{r highwater, fig.height=5, fig.width=7, message=FALSE, warning=FALSE, paged.print=TRUE}
# high water is wrack line - lowest road elevation
# lack of clearance = ceiling ht - WHI stain
# IDEA: Instead use ratios then score the ratio.
# NOTE: Use the fnction highwater_ratio defined in the prioritizations_funtions.R
# TODO: Need to complete recoding/rescaling and scoring.
# TODO: ONce we establish the method for scaling and scoring the high water risk use that same method for the lack of cleanance measure.

highwater <- LIculvertAssessmentData %>% 
  select(crossingID, starts_with("HWI"), starts_with("Road "), `Ceiling of Structure DS`, `Ceiling of Structure US`) %>% 
  mutate(#highRatio_US = `Road Surface US` - `HWI Wrack US` ,
         # highRatio_DS = `Road Surface DS` - `HWI Wrack DS` ,
         # clearance_DS = `Ceiling of Structure DS` - `HWI Stain DS`,
         # clearance_US = `Ceiling of Structure US` - `HWI Stain US`,
         highRatio_USv2 = highwater_ratio(`HWI Wrack DS`, `Road Surface DS`),
         highRatio_DSv2 = highwater_ratio(`HWI Wrack DS`, `Road Surface DS`),
         clearance_DSv2 = highwater_ratio(`HWI Stain DS`, `Ceiling of Structure DS`),
         clearance_USv2 = highwater_ratio(`HWI Stain US`, `Ceiling of Structure US`),
         hwc_ratio = pmax(highRatio_DSv2, highRatio_USv2, clearance_DSv2, clearance_DSv2, na.rm = T),
         Score_highWaterClearance = cut(x = hwc_ratio, breaks = c(-Inf, .25, .75, 1, 1.35, Inf), labels = 1:5, ordered_result = F))

highwater %>% ggplot(aes(hwc_ratio, fill = Score_highWaterClearance)) + 
  geom_histogram() +
  scale_fill_tnc("gradient1") 

highwater %>% ggplot(aes(Score_highWaterClearance, fill = Score_highWaterClearance)) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  scale_fill_tnc("gradient1")

# # datatable
# highwater %>% st_drop_geometry() %>% 
#   datatable(rownames = FALSE) %>% 
#   formatRound(-1, digits = 2)

(highwater %>% select(starts_with("high"), starts_with("clearance")) %>% st_drop_geometry() %>%
  ggpairs(title = "High water risk and lack of clearance components") +
    theme(strip.text.y = element_text(angle = 0))) 

highwater %>% st_drop_geometry() %>% 
  select(ends_with("v2")) %>% ggpairs(title = "Attempt at using the ratio approach") +
    theme(strip.text.y = element_text(angle = 0), strip.text = element_text(size = 7))

LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({highwater %>% select(crossingID, Score_highWaterClearance) %>% st_drop_geometry()}, by = "crossingID")

```


### C4. Erosion classification  
 
The ratio of scour pool width to channel width for both up and down stream sections. A large ratio indicates a larger scour pool. Score is based on the larger of the 2 ratios. 

```{r erosionClass2, message=FALSE, warning=FALSE, paged.print=TRUE}
# erosion classification is also scored in the ecological benefits.
# Repurpose the bulk of that code here

ec2 <- ec %>% mutate(Score_erosionconditionClass = submetric_erosionClass) %>% select(-submetric_erosionClass)
# 
# (ec2 %>% select(-crossingID) %>% st_drop_geometry() %>% 
#   ggpairs(title = "Erosion classification components correlations") + theme(strip.text.y = element_text(angle = 0))) %>% ggplotly()

# ec2 %>% 
#   datatable(rownames = FALSE) %>% 
#   formatRound(-1, digits = 2)
# Like what we see? Join to the master LIculvertPrioritization tibble.
# BUG: There's duplicate crossings entering here somehow.

ec2 %>% st_drop_geometry %>% tidyr::drop_na() %>% 
  ggplot(aes(x = erosionClass_dwnStrm, fill = as.factor(Score_erosionconditionClass))) + 
  geom_histogram() + 
  scale_fill_tnc("gradient1") + 
  scale_x_log10() +
  labs(title = "Downstream Erosion Classification", subtitle = "log transformed", fill = "submetric scoring")

ec2 %>% st_drop_geometry %>% tidyr::drop_na() %>% 
  ggplot(aes(x = erosionClass_upStrm, fill = as.factor(Score_erosionconditionClass))) + 
  geom_histogram() + 
  scale_fill_tnc("gradient1") + 
  scale_x_log10() +
  labs(title = "Upstream Erosion Classification", subtitle = "log transformed", fill = "submetric scoring")

ec2 %>% ggplot(aes(x = Score_erosionconditionClass, fill = as.factor(Score_erosionconditionClass))) +
  geom_bar() +
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  scale_fill_tnc("gradient1") + 
  # scale_fill_tnc("gradient1") + 
  labs(title = "Erosion Classification Distribution", fill = "submetric scoring")

LIculvertPrioritization <- LIculvertPrioritization %>%
  left_join({ec2 %>% select(crossingID, Score_erosionconditionClass) %>% st_drop_geometry()}, by = "crossingID")

```

### Total Infrastructure Condition Benefit Score  

_NOTE:_ Does not include the High water risk/Lack of clearance metrics for *ALL* crossings. 

```{r finalConditionSc, message=FALSE, warning=FALSE, paged.print=FALSE}


LIculvertPrioritization <- LIculvertPrioritization %>% rowwise() %>% 
  mutate(Total_InfrastructureBen = benefit_score(sum(Score_crossConditon, Score_partPrior, Score_highWaterClearance, Score_erosionconditionClass, na.rm = F))) %>% ungroup()


LIculvertPrioritization %>%  
  ggplot(aes(x = Total_InfrastructureBen, fill = as.factor(Total_InfrastructureBen))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Infrastructure Condition Benefit", x = NULL ) +
  theme(legend.position = "none")

```

***  




## Final Prioritization Scoring  
Now that's a distribution if I've ever seen one...

```{r finalScore, message=FALSE, warning=FALSE, paged.print=FALSE}
# There's a need to push out data from the assessments as well for the summary sheets, 
# TODO: Determine if the join should happen here or in a setup script elsewhere (ie. summarySheetSetup.R)
LIculvertPrioritization <- LIculvertPrioritization %>% rowwise() %>% 
  mutate(Total_Prioritization = sum(Total_Eco, Total_InfrastructureBen, Total_Resilience, Total_Trans, na.rm = F)) %>% ungroup()

LIculvertPrioritization %>%  
  ggplot(aes(x = Total_Prioritization, fill = as.factor(Total_Prioritization))) +
  scale_fill_tnc("gradient1") +
  geom_bar() + 
  geom_text(stat = "count", aes(label = ..count..), position = position_stack(vjust = 0.5)) +
  labs(subtitle = "Distribution of scores", title = "Total Benefit Scores", x = NULL ) +
  theme(legend.position = "none")

LIculvertPrioritization <- crossingLocations %>% left_join(LIculvertPrioritization)
write_rds(LIculvertPrioritization, path = "data/LIculvertPrioritizations.rds")

```



### Correlation Analysis  
Exploring relationships between model parameters. 
prefixed values of 'Score' are benefit scores, 'submetric' are calculated components that feed into benefit scoring.

#### Ecological Benefit Scores  

```{r fig.height=5, fig.width=5, message=FALSE, warning=FALSE, paged.print=FALSE}

LIculvertPrioritization %>% st_drop_geometry() %>%
  select(Score_MarshComplex, Score_marshAc, Score_dotr, Score_vegetation, Total_Eco) %>% 
  ggcorr(
    hjust = 1,
    size = 4,
    layout.exp = 1,
    label = T,
    label_alpha = T
  ) + labs(title = "Ecological Benefit") + 
  scale_fill_tnc("gradient1", discrete = F)

```
#### Resilience Benefit Scores  

```{r fig.height=5, fig.width=5, message=FALSE, warning=FALSE, paged.print=FALSE}

LIculvertPrioritization %>% st_drop_geometry() %>%
  select(Score_riskSLR_inundation, Score_stormsuge, Score_rainfallRisk, Score_marshmigpotAc, Total_Resilience) %>% 
  ggcorr(
    hjust = 1,
    size = 4,
    layout.exp = 1,
    label = T,
    label_alpha = T
  ) + labs(title = "Resilience Benefit") + 
  scale_fill_tnc("gradient1", discrete = F)

```
#### Transportation Benefit  
```{r fig.height=5, fig.width=5, message=FALSE, warning=FALSE, paged.print=FALSE}

LIculvertPrioritization %>% st_drop_geometry() %>%
  select(Score_Rd_EvacRte, Score_Rd_Funclass, Total_Trans) %>% 
  ggcorr(
    hjust = 1,
    size = 4,
    layout.exp = 1,
    label = T,
    label_alpha = T
  ) + labs(title = "Transportation Benefit") + 
  scale_fill_tnc("gradient1", discrete = F)
```

#### Infrastructure Condition Benefit

```{r message=FALSE, warning=FALSE, paged.print=FALSE}
LIculvertPrioritization %>% st_drop_geometry() %>%
  select(Score_crossConditon, Score_partPrior, Score_erosionconditionClass) %>% # TODO: High water indicator and total scores.
  ggcorr(
    hjust = 1,
    size = 4,
    layout.exp = 1,
    label = T,
    label_alpha = T
  ) + labs(title = "Infrastructure Condition Benefit") + 
  scale_fill_tnc("gradient1", discrete = F)
```

#### Across all categories

```{r fig.height=8, fig.width=8, message=FALSE, warning=FALSE, paged.print=FALSE}



LIculvertPrioritization %>% st_drop_geometry() %>%
  select(starts_with("Score"), starts_with("sub")) %>%
  ggcorr(angle = 0,
    hjust = .9,
    size = 4,
    layout.exp = 1,
    label = T,
    label_alpha = T,
  ) + labs(title = "All Metrics")  +
  scale_fill_tnc("gradient1", discrete = F)

```

### References: 
[^Resilient Tidal Crossings]: New Hampshire Department of Environmental Services. 2019. “Resilient Tidal Crossings:An Assessment and Prioritization to Address New Hampshire’s Tidal Crossing Infrastructure for Coastal Resilience”.  R-WD-19-20. Portsmouth, NH. Available online at: https://www.des.nh.gov/organization/divisions/water/wmb/coastal/resilient-tidal.htm

